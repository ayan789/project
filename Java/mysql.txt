mysql
三大范式：
属性不可拆分属性不可重复 
一条数据的信息只与一列对应
数据不能存在传递关系
需求>性能>表结构
char和varchar的区别：char的长度是不可变的，而varchar的长度是可变的。
乐观锁:数据版本 数据库表中版本号与此版本号相同则能更新成功
悲观锁:先获取锁再进行业务操作

用户信息表 用户基本信息
用户关系表 用户ID 关系分类
会员表 会员ID 会员等级
会员等级表 会员等级 会员名称 会员特权
会员等级变更表 会员ID 会员等级 等级获取时间
卡券信息表 卡券基本信息
用户卡券使用表 用户ID 卡券ID 生效时间 过期时间
用户积分表 用户ID 当前积分
用户余额表 用户ID 当前余额
用户投诉状态表 用户ID 投诉内容 投诉状态
用户评价表 用户ID 被评价用户ID 评价内容 
用户消费表 用户ID 消费金额 消费清单
用户行为记录表（消费记录 充值记录 退费记录 投诉记录 评价记录）

购物车表
主订单表
子订单表
相同产品不同规格的主订单ID一致子订单ID不同
订单明细表
订单支付表
订单物流快照表
订单收货信息表
订单评论表
订单发货信息表（商家看）

索引
分表分库
左右链接
大数据量 Mysql8 hash join 等值链接 效率更快


存储过程游标

drop procedure if exists abc_pro;

CREATE PROCEDURE abc_pro()
BEGIN
 -- 需要定义接收游标数据的变量
      DECLARE var_price VARCHAR(20);
			DECLARE var_pay_time TIMESTAMP DEFAULT NULL ;
  -- 遍历数据结束标志
      DECLARE done INT DEFAULT FALSE;
  -- 游标
      DECLARE cur CURSOR FOR  SELECT  price,pay_time FROM cms_aw_order;
  -- 将结束标志绑定到游标
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
  -- 打开游标
  OPEN cur; 
  -- 开始循环
     read_loop: LOOP    
    -- 提取游标里的数据，这里只有一个，多个的话也一样；
     FETCH cur INTO var_price,var_pay_time;
    -- 声明结束的时候
     IF done THEN
     LEAVE read_loop;
     END IF;
    -- 这里做你想做的循环的事件
     INSERT INTO cms_aw_order_copy (price,pay_time) VALUES(var_price,var_pay_time); 
  END LOOP;
  -- 关闭游标
     commit;
  CLOSE cur;
END

call abc_pro();



MVCC create CRUD version delete version 系统版本号
无锁读和有锁读
有锁读分共享和排他
java mycat、redis，并发和PV，dubbo和springcloud

DATE_FORMAT,索引会失效,导致全表扫描


最大化利用索引 避免全表扫描 减少无效数据查询

不要用OR用union

不要用in用exists

不要判断NULL值

不要判断1=1

垂直拆分和水平拆分
垂直拆分(各个表拆分到数据库)
水平拆分(id取模)

接口最少暴露原则
旁支逻辑异步化
数据补偿
墨菲定律 SOP（标准化解决方案）
select * 对于无用的大字段，如 varchar、blob、text，会增加 io 操作



ALTER TABLE `t_cust_activity_tag` ADD UNIQUE ( `activity_name`,activity_tag )
ON DUPLICATE KEY UPDATE 
		id = VALUES(id),
		activity_id = VALUES(activity_id),
		activity_name = VALUES(activity_name),
		activity_tag_id = VALUES(activity_tag_id),
		activity_tag = VALUES(activity_tag),
		config_soft = VALUES(config_soft)
